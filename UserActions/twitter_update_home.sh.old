#! /bin/bash

INTERFACE="ra0"
DEVICE_IP="192.168.1.77"
CAPTURE_FILTER="host ${DEVICE_IP}"
DISPLAY_FILTER="not arp and not bjnp and not dns and not ntp and not(ip.src==216.58.192.0/19 or ip.dst==216.58.192.0/19) and ssl"
TIMEOUT=10
PACKETS_TIME_MAX_DELTA=4.5

# name of this script
FILENAME="$0"

# the output pcap has same name as the script
OUTPUT_PCAP=${FILENAME%.*}

# USER ACTION INIT

# start Twitter Main Activity 
adb shell am start "com.twitter.android/com.twitter.app.main.MainActivity"

# wait for it to get loaded
sleep 2

# go to the Home (suppress warning messages)
adb shell input tap 184 400 1>/dev/null

# wait for the home to get loaded
sleep 0.5

# scroll to first message (suppress warning messages)
adb shell input roll 0 -500 1>/dev/null

# start capturing; suppress statistics (with "-l") as well as messages to standard output and error
tshark -i "${INTERFACE}" -l -q -n -f "${CAPTURE_FILTER}" -w "${OUTPUT_PCAP}.pcap" > /dev/null 2>&1 &

# get the pid of the background process: this is needed to stop it as soon as the user action has finished
TSHARK_PID=$!

# wait for tshark to be ready to capture
sleep 5

# time at the moment when the capture starts (in seconds): we will consider only packet whose timestamp
# is greater than this, in order to be sure to analyse only the traffic generated by the user action.
# The format is "seconds since midnight of first january 1970
START_TIME=$(date -u) # '+%s.%N')
echo "start=$START_TIME"

# USER ACTION START

# swipe in order to refresh the home (suppress warning messages)
adb shell input swipe 160 560 160 3028 1>/dev/null

# capture for TIMEOUT seconds
sleep $TIMEOUT

# stop capturing
kill "$TSHARK_PID"

# USER ACTION END

# COLLECT TRACE -> get a CSV out of the trace

# we have to consider only the packets whose timestamp is bigger than "START_TIME", i.e. those generated by the user action
# also we expect that two successive packets in the flow generated by the user action are at most PACKETS_TIME_MAX_DELTA seconds far from each other
# => copy to the CSV only those packets which are PACKETS_TIME_MAX_DELTA seconds far from each other

while

	# get number of packets captured: if less than two packets have been capture so far, keep capturing
	# (the first line in the pcap file contains the headers)

	#TOTAL_PACKETS_CAPTURED=$(tshark -i "${INTERFACE}" -e "_ws.col.Time" -e "frame.number" -e "ip.src" -e "ip.dst" -e "tcp.srcport" -e "tcp.dstport" -e "frame.len" -e "_ws.col.Protocol" -e "_ws.col.Absolute time" -T "fields" -r "${OUTPUT_PCAP}.pcap" -E header=y -Y "${DISPLAY_FILTER}" | wc -l)
	#if [ "$TOTAL_PACKETS_CAPTURED" -lt 3 ]
	#then
	#	continue
	#fi

	# at this point at least two packets has been captured.
	# we want to consider only packets from the flow generated by the user action, so skip all the packets
	# generated by actions preceeding start time 
	
	#LAST_BUT_ONE_PACKET_TIME=$(tshark -i "${INTERFACE}" -e "_ws.col.Time" -e "frame.number" -e "ip.src" -e "ip.dst" -e "tcp.srcport" -e "tcp.dstport" -e "frame.len" -e "_ws.col.Protocol" -e "_ws.col.Absolute time" -T "fields" -r "${OUTPUT_PCAP}.pcap" -E header=y -Y "${DISPLAY_FILTER}" | tail -2 | sed '1q;d' | awk '{print $9}')
	LAST_BUT_ONE_PACKET_TIME=$(tshark -i "${INTERFACE}" -e "_ws.col.Time" -e "frame.number" -e "ip.src" -e "ip.dst" -e "tcp.srcport" -e "tcp.dstport" -e "frame.len" -e "_ws.col.Protocol" -e "_ws.col.Absolute time" -T "fields" -r "${OUTPUT_PCAP}.pcap" -E header=y -Y "${DISPLAY_FILTER}" | tail -2 | awk '{print $9}')
	
	# transform from  UTC time into the same format as START_TIME: they are easier to compare in this way
	# in case the time_zone is not UTC, set it to UTC, to make it comparable with the start time, by adding 3600 (one hour) to the
	# counter of seconds
	
	TIME_ZONE=`date -d "${LAST_BUT_ONE_PACKET_TIME}" | awk '{split($0,a,", ")} END {print a[3]}'`
	if [ "$TIME_ZONE" != "UTC" ]
	then
		SECONDS_NOT_UTC=$(date -d "${LAST_BUT_ONE_PACKET_TIME}" '+%s.%N' | awk '{split($0,a,".")} END {print a[1]}')
		NANOSECONDS=$(date -d "${LAST_BUT_ONE_PACKET_TIME}" '+%s.%N' | awk '{split($0,a,".")} END {print a[2]}')
		echo "not utc:$SECONDS_NOT_UTC"
		SECONDS_UTC=$((SECONDS_NOT_UTC+3600))
		echo "utc:$SECONDS UTC"
		LAST_BUT_ONE_PACKET_TIME="${SECONDS_UTC}.${NANOSECONDS}"
		echo "final:$LAST_BUT_ONE_PACKET_TIME"
	fi
	#echo "before $LAST_BUT_ONE_PACKET_TIME"
	#LAST_BUT_ONE_PACKET_TIME=$(date -d "${LAST_BUT_ONE_PACKET_TIME}") # '+%s.%N')
	#echo -e "last but one:$LAST_BUT_ONE_PACKET_TIME\n"

	
	LAST_PACKET_TIME=$(tshark -i "${INTERFACE}" -e "_ws.col.Time" -e "frame.number" -e "ip.src" -e "ip.dst" -e "tcp.srcport" -e "tcp.dstport" -e "frame.len" -e "_ws.col.Protocol" -e "_ws.col.Absolute time" -T "fields" -r "${OUTPUT_PCAP}.pcap" -E header=y -Y "${DISPLAY_FILTER}" | tail -1 | awk '{print $9}')

	# transform from  UTC time into the same format as START_TIME: they are easier to compare in this way

	LAST_PACKET_TIME=$(date -d "${LAST_PACKET_TIME}") # '+%s.%N')
	echo -e "last:$LAST_PACKET_TIME\n"
	
	#PACKETS_TIME_DELTA=$( echo "$LAST_PACKET_TIME-$LAST_BUT_ONE_PACKET_TIME" | bc -l )
	#echo "delta:$PACKETS_TIME_DELTA"
	#COMPARE_LAST_TWO_PACKETS=$( echo $PACKETS_TIME_DELTA'<'$PACKETS_TIME_MAX_DELTA | bc -l )
	#ELAPSED_TIME=$( echo $START_TIME+$LAST_PACKET_TIME | bc -l )
	#echo "elapsed:$ELAPSED_TIME"
	#CHECK_TIMEOUT=$( echo $ELAPSED_TIME'<'$PACKETS_TIME_MAX_DELTA | bc -l )
	#if [ "$COMPARE_LAST_TWO_PACKETS" == 0 ] || [ "$CHECK_TIMEOUT" == 0 ]
	#then
	#	echo "killing because:$COMPARE_LAST_TWO_PACKETS time:$CHECK_TIMEOUT"
	#	kill "$TSHARK_PID"
	#	break
	#fi
do :; done

# wait for the capturing background process to finish
wait

# stop the app
adb shell am force-stop "com.twitter.android"

# USER ACTION FINISHED

